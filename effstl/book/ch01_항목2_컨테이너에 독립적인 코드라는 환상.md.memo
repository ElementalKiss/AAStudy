# 항목 2 : "컨테이너에 독립적인(container-independnt) 코드" 라는 환상을 조심하자

# STL
* STL은 일반화에 기초를 두고 만든 프로그래밍 장치

| C  |   STL  |
|----|--------|
|배열|컨테이너|
|함수|알고리즘|
|포인터|반복자|

# 컨테이너의 차이
* 모든 컨테이너에 사용할 수 있는 코드를 만들려고 하지만 컨테이너들의 차이를 알게 되면 그것은 절대로 불가능.
* 표준 연속 메모리 컨테이너는 임의 접근 반복자 사용 가능
* 노드 기반 컨테이너는 push_front, push_back 지원, 연관 컨테이너는 그렇지 않음
* 연관 컨테이너에서는 로그 시간의 복잡도를 가진 lower_bound, upper_bound, equal_range 멤버 함수 사용 가능 하지만 시권스 컨데이너는 지원하지 않음.
* insert, erase 기본적인 함수는 시퀀스 컨테이너와 연관 컨테이너 모두 지원하지만 동작 원리가 다름.
	* insert: 시퀀스 컨테이너에 어떤 객체를 insert하면 삽입한 위치에 그 객체가 그대로 있지만, 연관 컨테이너는 자체의 정렬 방식에 맞게 그 객체를 이리저리 옮김.
	* erase: 시퀀스 컨테이너에서 호출 시 반복자가 새로 봔환되지만, 연관 컨테이너에 대해 호출하면 아무것도 반환되지 않음.
* 각 컨테이너들은 반복자, 포인터, 참조자를 무효화 시키는 방식이 다름
	* deque의 insert는 모든 반복자를 무효화, capacity 지원되지 않음
	* vector의 insert는 모든 포인터와 참조자를 무효화
* vector<bool>은 vector처럼 동작하지 않으며 STL의 공식 컨테이너가 아님
	* http://yamaecode.tistory.com/6
	* [http://blog.naver.com/dev_kr/220794958656] 공간 최적화를 이유로 bool은 비트 단위로 저장되며 기존 표준 컨테이너가 제공하는 기능과 인터페이스가 전부 제공되지 않음.
* set은 하나의 객체를 저장, map은 객체의 pair를 저장.
* map은 operator[]을 지원하지만 multimap은 지원하지 않음.

# typedef
* 수시로 컨테이너 타입을 바꿔서 쓰고 싶다면 typedef를 써서 캡슐화를 하자.
* 하지만 typedef를 통한 캡슐화는 지극히 문자적이기 때문에 문제가 될 수 있는 상황들을 막아주지는 않음.
* 이를 해결하고 싶다면 class를 이용하여 컨테이너는 private 영역에 숨기고 필요한 정보는 인터페이스를 통해 개방

