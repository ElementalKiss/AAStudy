# 항목 44: 같은 이름을 가진 것이 있다면 일반 알고리즘 함수보다 멤버 함수가 더 낫다

## 같은 이름의 멤버 함수가 더 나은 이유
* 멤버 함수가 더 빠르고 해당 컨테이너와 더 잘 맞물려져 있음 (특히 연관 컨테이너)
* 같은 이름을 가진 알고리즘과 멤버 함수는 대개 정확히 똑같은 동작을 하지 않기 때문

## 예제
``` c++
    std::set<int> s;

    for (int i = 0; i < 1000000; i++) {
        s.insert(i);
    }

    std::set<int>::iterator finded = s.find(727);
    std::set<int>::iterator algorithmFinded = std::find(s.begin(), s.end(), 727);
```
* find
    * 멤버
        * 로그 시간에 실행
        * 약 40(최악의 경우)에서 약 20(평균)번의 비교
        * 동등성[(!a1 < a2) && !(a2 && a1)] 사용
    * 알고리즘
        * 선형 시간에 실행
        * 1,000,000(최악의 경우)에서 500,000(평균)번의 비교
        * 상등성[operator==] 사용
* count
    * 멤버: 키를 가진 페어(pair)만 세고 값(value)는 관심 없음
    * 알고리즘: 페어에 들어있는 두 개의 멤버를 모두 고려하여 탐색 수행

## list 함수 비교
* remove, remove_if, unique, sort, merge, reverse
    * 멤버: 객체 복사 X (포인터를 조작 할 뿐)
    * 알고리즘: 객체 복사 O
* remove, remove_if, unique
    * 멤버: 객체를 없애줌
    * 알고리즘: 객체가 없어지지 않기 때문에 erase 호출 필요
* sort
    * 알고리즘 sort list에 적용 불가
    * list의 반복자는 양방향 반복자이기 때문에
* merge
    * 멤버: 작업 대상의 되는 범위 바꿀 수 있음
    * 알고리즘: 작업 대상의 되는 범위 바꿀 수 없음

## 그 외
* 대부분의 연관 컨테이너는 빨강-검정 트리로 구현 되어 있음
* 효율을 고려한다면 로그 시간 탐색 알고리즘을 합치거나 비표준 해쉬 컨테이너를 사용