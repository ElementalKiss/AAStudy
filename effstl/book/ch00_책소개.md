# 책소개

* 너희는 C++ STL 봉지를 뜯어 까먹을 줄은 알지만, 효과적으로 지져 먹고 데쳐 먹고 볶아 먹을 줄은 모른다. 이런 독자들을 위해 이 책을 섰다.
* 어이없는 상황을 피하고 우아하게 STL 프로그래밍을 하자.
* 자원 누수, 이식되지 않는 코드, 불확실하게 동작하는 코드 등의 고난을 피하는데 큰 도움이 될 것이다.

# STL의 정의, STL의 사용, STL의 확장에 대해 한마디

* 필자의 STL의 정의: 반복자를 가지고 동작하는 C++ 표준 라이브러리의 일부분
* 정의에는 표준 컨테이너(string 포함), iostream 라이브러리의 일부, 함수 객체, 알고리즘 모두 포함된다.
* 반복자 지원이 미약한 것을 제외: 표준 컨테이너 어뎁터(stack, quere, priority_queue), bitset, valarry, C++ Array
* C++ 라이브러리를 확장한 것들 또한 제외: 해쉬 포인터(hashed pointer), 싱글 링크드 리스트, 표준이 아닌 변이형 함수 객체들.
* STL에 꼭 알아두어야 할 필요가 있는 것들은 포함: 해쉬 포인터는 다음 버전의 C++ 표준에 들어갈 가능성이 높다.
* STL의 using에 초점을 두었다. 자체 알고리즘을 만들거나 반복자를 설계하는 방법에 대해선 기술하지 않음.
* STL 확장은 함수 객체에 대해서만 기술했다.

# 자료 인용에 대하여

* 인용 예시: 조스티스의 "The C++ Standard Library"[3]
* 너무 자주 사용하기에 인용 번호를 빼는 항목: 표준안("International Standard for C++"[5]), Effective C++, More Effective C++.

# STL과 표준

# 참조 카운팅

* STL을 이야기하면 참조 카운팅은 필연적으로 따라온다.
* 포인터의 컨테이너를 기반으로 한 설계엔 참조 카운팅을 무시할 수 없다.(항목7, 항목 33) 그리고 string 클래스.
* More Effective C++ 항목 28, 29 를 참조하면 도움이 된다.

# string과 wstring

* string에 대해 설명한 모든 내용은 유니코드 문자열 클래스 wstring에도 적용된다.
* string과 char, char*의 관계는 wstring과 wchar_t, wchar_t의 관계와 동일하다.
* 필자는 유니코드에 대해 직접적으로 언급하지 않지만 STL은 이를 지원하므로 알아두라는 뜻.

# 용어

# 예제 코드에 대하여

# 수행 효율에 대한 항목은 여기에

# Effective STL에 수록된 가이드라인에 대하여