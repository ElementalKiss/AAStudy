# 항목 15 : 잊지 말자! string은 여러 가지 방식으로 구현되어 있다는 사실을..

# string의 크기 즉, sizeof(string) 의 크기는 답이 하나가 아니다.

* char* 크기와 같은 경우도 빈번한 반면, char* 의 무려 일곱 배(32bit 환경에서 28바이트)나 되는 경우도 있다.
* (우리집은 x86에서 28bite, x64에서 40bite)

# string 은 거의 모두 다음과 같은 정보를 가지고 있게끔 구현되어있다.

* 문자열의 크기(size). 즉, string 객체에 담겨져 있는 실제 문자열의 길이
* 문자를 담아두는 메모리의 용량(capacity). > size는 현재 요소의 개수, capacity는 담을 수 있는 요소의 개수.
* 문자열의 값(value). 즉, 문자열을 이루는 문자들

# 여기까진  기본이고, 다음 정보는 선택적으로  저장될  수 있다.

* 할당자(allocator)의 사본. (STL 할당자에 대한 이상한 규칙 때문, 항목 10에서..)
* 참조 카운트를 사용하는 string의 경우 문자열 값에 대한 참조 카운트(reference count)
* 위의 정보는 구현된 라이브러리에 따라 갖가지 양상으로 저장, 관리되고 있다.

# 필자가 조사한 네 가지 라이브러리의  string 구현 코드에 대해 알아보자.

* A 타입 
    - 할당자 사본
    - 문자열의 크기
    - 용량
    - 참조 카운트
    - 문자열 값을 담는 동적 할당 버퍼를 물고 있는 포인터
    - 기본 할당자를 사용할 경우 포인터의 네 배 크기, 커스텀 할당자를 사용하면 더 커질 수도 있다.

* B 타입
    - 포인터의 크기와 똑같다.
    - 내부에 포인터 외에 들어있지 않기 때문(기본 할당자를 사용한다는 가정 하에)
    - 포인터는 동적 할당된 메모리 블록을 가리키며, 이 블록에는 문자열의 크기, 용량, 참조 카운트, 문자열 값을 가지는 동적 할당 버퍼에 대한 포인터가 들어 있다.
    - 이 외에도 다중 쓰레드 환경에서의 동시성 제어에 관련된 데이터가 몇 개 더 들어있다. (포인터 크기의 여섯 배)
    
* C 타입
    - 포인터의 크기와 항상 똑같다.
    - 하지만, 내부에 들어 있는 포인터가 가리키는 데이터는 B와 다르다.
    - 문자열의 크기, 용량, 참조 카운트, 문자열 값이 들어있고, 객체 별로 할당자를 쓸 수 있도록 지원하고 있지는 않는다.
    - 문자열 값 공유처리(참조 카운팅)에 관련된 데이터도 포함되지만 초기 상태에서 공유되지 않게 세팅될 수 있다.

* D 타입
    - 포인터 크기의 일곱 배나 된다.(기본 할당자로 가정)
    - 참조 카운팅이 전혀 지원되지 않고(다중 쓰레드 지원 안함), 특이하게 15 문자 분의 문자열을 담을 수 있는 버퍼가 있다.
    - "단문자열 최적화(small string oprimization)"이라 말하는 특징
    - 이 객체는 용량이 15 문자를 넘으면 버퍼의 앞부분을 동적 할당 버퍼를 가리키는 포인터로 사용한다. (나머지는 미사용 영역으로 남게 된다)

# 요약

* string의 문자열은 많은 라이브러리에서 참조 카운팅을 사용하지만, 아닌 경우도 있다. 참조 카운팅을 막는 방법도 제공한다. 한 문자열이 아주 자주 복사되고 어떤 어플리케이션 자체에서 문자열 복사를 많이 하지 않을 때에만 참조 카운팅이 효과적이다.

* string 객체 자체의 크기는 포인터의 크기에서 일곱 배까지 다양하다.

* 문자열을 새로 생성할 때 필요한 메모리 할당의 회수는 0번, 1번, 또는 2번이 될 수도 있다.

* 둘 이상의 string 객체가 문자열 크기나 용량 정보를 함께 가지고 있을 수도, 아닐 수도 있다.

* 문자 버퍼를 위해 할당하는 메모리의 최소량에 대한 정책은 구현된 라이브러리마다 천차만별

- STL을 효과적으로 사용하기 위해서는 string을 어떻게 구현해 놓았는지를 알 필요가 있다.
- 여러 개의 STL 플랫폼에서 동작하는 코드를 작성하고 있으며 까다로운 수행 성능 조절이 필요할 경우라면 특히