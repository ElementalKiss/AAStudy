# 항목 1 : 적재적소에 알맞은 컨테이너를 사용하자

# 컨테이너의 종류

* Sequence Container : vector, string, deque, list
* Associative Container : set, multiset, map, multimap
* 비표준 Sequence : slist(single linked list), rope(대용량 string).
* 비표준 Associative Constainer : hash_set, hash_multiset, hash_map, hash_multimap.
* String 대신 사용되는 vector<char> : 간혹 이렇게 쓰면 괜찮을 때가 있다.
* 표준 연관 컨테이너 대신 사용되는 vector : vector가 수행 속도나 크기 면에서 표준 연관 컨테이너보다 더 나은 경우가 있다.
* STL에 속하지 않는 표준 컨테이너 : 배열(C++ 배열), bitset, valarray, stack, queue, priority_queue.

# 백터, 리스트, 덱 선택을 고려할 때 알아두어야 할 사항

* 백터 : 기본적으로 사용되는 시퀀스.
* 리스트 : 시퀀스의 중간에 비번한 삽입, 삭제가 수행될 필요가 있을 때 사용한다.
* 덱 : 대부분의 삽입과 삭제가 시퀀스의 앞과 끝에서 일어날 경우 사용한다.

# STL의 컨테이너는 연속 메모리(contiquous-memory) 컨테이너와 노드 기반(node-based) 컨테이너로 나눌 수 있다.

## 연속 메모리 컨테이너

* 동적 할당된 하나 이상의 메모리 단위(Chunk)에다 데이터 요소를 저장해 두는 컨테이너.
* 삽입과 삭제가 일어났을 시, 같은 메모리 단위에서 있던 다른 요소들이 압 혹은 뒤로 밀려나 공간을 만들던지 메운다.
* 수행 성능의 발목을 잡을 수 있다.
* 예외 안전성에도 영향을 미친다.
* vector, string, deque가 있다. (+ 비표준 컨테이너 rope)

## 노드 기반 컨테이너

* 동적 할당된 하나의 메모리 단위에다가 하나의 요소만을 저장한다.
* 요소를 삽입, 삭제 했을 시, 노드의 포인터만이 영향을 받는다.
* list, slist 노드 기반. 전형적으로 균형(balanced tree)로 구현되어 있다.

# 적재적소에 맞는 컨테이너

| 조건                            | 적절한 컨테이너                      |
| ----------------------------- | ----------------------------- |
| 컨테이너의 아무 위치에 요소를 삽입하는가?       | 시퀀스 컨테이너                      |
| 컨테이너 내의 요소들의 순서 결정에 직접 관여하는가? | YES - 해쉬 컨테이너 X, NO - 해쉬 컨테이너 |
| 표준 C++에 포함된 컨테이너를 사용해야 한다면?   | 해쉬 컨테이너, slist, rope는 쓸 수 없다. |
| 어떤 타입의 반복자가 필요한가?             | 임의 접근 반복자                     |