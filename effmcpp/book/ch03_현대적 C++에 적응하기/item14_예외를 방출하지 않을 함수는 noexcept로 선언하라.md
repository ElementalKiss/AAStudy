# 항목 14: 예외를 방출하지 않을 함수는 noexcept로 선언하라

## 예외 명세(exception specification)
### C++98

* 프로그래머들 사이에 C++98의 예외 명세가 득보다 실이 크다고 여겨지고 있다.
* 함수가 방출(emit)하는 예외를 요약해야 했으며 함수의 구현이 변경되면 명세도 함께 변경해야 한다. 이는 클라이언트 코드가 깨질 수 있는 위험이 있다.

### C++11

* C++11 제정 과정에서 예외 방출에 대해 '하나라도 예외를 방출하는가' 여부라는 점에 초점을 두게 되었다.
* C++11의 예외 명세는 '예외를 하나라도 던지는지' '하나도 던지지 않는지'의 이분법적 정보가 배경에 깔려있다.
* C++98의 예외 명세도 유효하나, 비권장(deprecate) 기능으로 분류된다.
* 예외를 방출하지 않는 함수는 **noexcept**라는 키워드를 사용하면 된다.

## 인터페이스 설계

* 함수를 noexcept로 선언하면 해당 함수를 호출하는 코드에서 예외 안정성과 효율성을 확보할 수 있다.
* noexcept가 없다면 인터페이스 명세가 허술함을 의미한다.

## 최적화 여지, 더 나은 목적 코드

* noexcept의 또 하나의 장점은 컴파일러가 더 나은 목적 코드(object code)를 산출하는데 도움이 된다는 것이다.
```c++
// 둘 다 예외를 방출하지 않음.
int f(int x) throw();   // C++98
int f(int x) noexcept;  // C++11
```

* 어떤 예외가 발생하여 f 바깥으로 나올 때, throw를 이용하면 스택 되감기를 한다.(rewind)
* noexcept로 선언하면 스택 되감기를 **할 수도** 있고 **안 할 수도** 있다.
* 컴파일러의 최적화기(optimizer)는 예외가 함수 밖으로 전파 될 때 선택의 **유연성**을 가진다.

## std::vector와 move

## pair

## 예외중립성

## 결론

* noexcept는 함수의 인터페이스의 일부. 해당 함수를 호출하는 사람이 noexcept 여부에 의존할 수 있다.
* noexcept 함수는 non-noexcept 함수보다 최적화의 여지가 크다.
* noexcept는 move 연산들과 swap, 메모리 해제 함수, 소멸자들에 유용하다.
* 대부분의 함수는 noexcept가 아니라 예외에 중립적이다.
