
# 항목 39: 단발성 사건 통신에는 void 미래 객체를 고려하라


## 스레드 간 통신을 처리하는 가장 나은 방법은 무엇일까?

* 조건 변수(condition variable, 줄여서 condvar)를 사용하는 방법
- 조건을 검출하는 과제를 검출 과제(detecting task),
  그 조건에 반응하는 과제를 반응 과제(reacting task)라고 칭할 때
  반응 과제는 하나의 조건 변수를 기다리고, 검출 과제는 사건이 발생하면 그 조건변수를 통지하면 된다.

* 검출 과제 쪽의 코드
```cpp
  std::condition_variable cv;   // 사건을 위한 조건 변수
  std::mutex m;                 // cv와 함께 사용할 뮤텍스

  ...               // 사건을 검출
  cv.notify_one();  // 반응 과제에 알림
  // 반응 과제가 여러 개라면 cv.notify_all()
```

* 반응 과제 쪽의 코드
```cpp
  ...                                     // 반응 준비
  {                                       // 임계 영역
    std::unique_lock<std::mutex>> lk(m);  // 뮤텍스를 잠금
    cv.wait(lk);                          // 통지를 기다림(제대로 된 방식이 아님)

    ...                                   // 사건에 반응(m이 잠긴 상태)
  }                                       // 임계 영역을 닫으면 lk의 소멸자가 m을 해제한다.
  ...                                     // 계속 반응(m은 풀린 상태)
```

* 조건 변수에 대해 wait를 호출하기 전에 unique_lock 객체로 뮤텍스를 잠근다.
 (조건 변수에 대한 wating 연산 전에 뮤텍스를 잠그는 것은 스레드 적용 라이브러리에서 흔히 볼 수 있는 과정)
* 위 코드는 잘 작동하지만 그래도 먼가 잘못된 점이 있다. 이를 코드 냄새(code smell)가 난다고 표현하기도 한다.

## 코드 냄새의 근원은 뮤텍스가 필요하다는 점
* 뮤텍스는 공유 자료에 대한 접근을 제어할 때 쓰이나, 검출 과제와 반응 과제에 그런 제어가 필요 없을 수 있다.
* 두 과제가 서로 마주칠 일이 없다면 뮤텍스는 필요하지 않는다.

## 외에도 반드시 처리해야 할 문제점이 두 가지 더 있다.
* 만일 반응 과제가 wait를 실행하기 전에 검출 과제가 조건 변수를 통지하면 과제가 멈추게 된다(hang).
  그러면 반응 과제는 영원히 통지를 기다리게 된다.
* wait 호출문은 가짜 기상(spurious wakeup)을 고려하지 않는다.
  - 조건 변수가 통지되지 않았는덷 깨어날 수 있다는 것은 스레드 적용 API에서 흔히 있는 일이다.
    가짜 기상 문제를 제대로 처리하려면, 깨어난 후 바로 조건이 정말 발생했는지 확인해야 한다.
  - C++의 조건 변수 API 에서는 이러한 확인을 간편하게 할 수 있다.
    조건을 판정하는 람다 또는 함수 객체를 wait에 넘겨줄 수 있기 때문이다.
```cpp
  cv.wait(lk, []{ return 사건 발생 여부;});
```
  - 이러한 능력을 활용하려면, 기다리던 조건이 정말 참인지를 반응 과제가 판단할 수 있어야 하지만 지금까지 고려하던 예에서 반응 과제가 기다리는 조건은 특정 사건의 발생,
    그 발생 여부를 검출하는 것은 검출 과제의 몫이다.
    반응 과제는 조건을 판단하지 못할 수 있을 수도 있다. (그것을 직접 판단할 수 있었다면, 애초에 조건 변수를 기다리지도 않았을 테고..)

## 다음 대안으로 공유 bool 플래그를 생각하는 개발자가 많을 것이다.
* 우선 bool 플래그 하나를 false로 초기화 해두고 검출 스레드는 사건 발생을 검출하면 그 플래그를 설정
```cpp
  std::atomic<bool> flag(false);    // 공유 플래그
  ...                               // 사건 검출
  flag = true;                      // 반응 과제에 통지
```

* 반응 스레드는 그냥 이 bool 플래그를 폴링(polling, 주기적 점검)하고, 플래그가 설정되면 반응한다.
```cpp
  ...               // 반응 준비
  while (!flag);    // 대기
  ...               // 반응
```

* 이러한 방식은 조건 변수 기반 설계의 단점들이 전혀 없지만, 폴링 비용이 가장 큰 단점
- 플래그가 설정되기 전에는 반응 과제는 사실상 차단 상태지만 여전히 실행중이다.

## 조건 변수 기반과 플래그 기반 설계를 결합하는 것도 흔하다.
* 사건 발생 여부는 플래그로, 그 플래그에 대한 접근을 뮤텍스로 동기화
* 이 경우 플래그에 대한 동시 접근을 뮤텍스로 방지하므로 플래그를 std::atomic 으로 둘 필요는 없다.

* 검출 과제
```cpp
  std::condition_variable cv;
  std::mutex m;

  bool flag(false);
  
  ...                                   // 사건 검출
  
  {
    std::lock_guard<std::mutex> g(m);
    flag = true;                        // 반응 과제에 통지(1)
  }                                     // g의 소멸자에서 m을 푼다

  cv.notify_one();                      // 반응 과제에 통지(2)
```

* 반응 과제
```cpp
  ...                                   // 반응 준비
  {
    std::unique_lock<std::mutex> lk(m);
    cv.wait(lk, [] { return flag; });   // 가짜 기상을 방지하기 위해 플래그 검사

    ...                                 // 사건에 반응(m은 잠긴 상태)
  }

  ...                                   // 계속 반응(m은 풀린 상태)
```

* 검출 과제는 사건이 확실히 발생했음을 플래그로 설정함으로써 반응 과제에 알리지만,
  반응 과제가 그 플래그를 점검하게 하려면 먼저 조건 변수를 통지해서 플반응 과제를 깨워야 한다.
  깔끔하다고 할 수 없다..

## 대안은 검출 과제가 설정한 미래 객체를 반응 과제가 기다리게 하는 것
  (조건 변수와 뮤텍스, 플래그를 아예 사용할 필요가 없음)
* item 38에서 설명된 future 객체는 프로그램의 한 장소에서 다른 장소로 정보를 전송해야 하는 모든 상황에서 사용할 수 있다.

* 검출 과제에는 std::promise 객체를 하나 두고, 반응 과제에는 그에 대응되는 future 객체를 하나 둔다.
* 기다리던 사건이 발생했음을 인식하면 검출 과제는 자신의 std::promise를 설정
* 그 동안 반응 과제는 자신의 미래 객체에 대해 wait를 호출해 둔 상태
* wait 호출은 std::promise가 설정될 때까지 차단된다.

* std::promise와 future 모두 형식 매개변수를 요구하는 템플릿이지만 지금은 딱히 전송할 자료가 없다.
* 이럴땐 void를 쓰면 된다. 전달할 자료가 없음을 뜻한다.

* 결론적으로 검출 과제는 std::promise<void>를, 반응 과제는 std::future<void>를 사용하면 된다.
* 검출 과제는 기다리던 사건이 발생하면 자신의 std::promise<void>를 설정하고, 반응 과제는 자신의 future 객체에 대해 wait 호출
* 반응 과제가 아무런 자료도 받지 않지만 검출 과제가 std::promise에 대해 set_value를 호출해서 자신의 void 자료를 기록했음을 알 수 있다.

```cpp
  std::promise<void> p;     // 통신 채널에서 사용할 객체

  // 검출 과제 코드
  ...                       // 사건 검출
  p.set_value();            // 반응 과제에게 통지

  // 반응 과제 코드
  ...                       // 반응 준비
  p.get_future().wait();    // p에 해당하는 future 객체를 기다림

  ...                       // 사건에 반응
```


## 기억해 둘 사항들
* 간단한 사건 통신을  수행할 때, 조건 변수 기반 설계에는 여분의 뮤텍스가 필요
  검출 과제와 반응 과제의 진행 순서에 제약이 있으며,
  사건이 실제로 발생 했는지를 반응 과제가 다시 확인해야 한다.
* 플래그 기반 설계를 사용하면 그런 단점들이 없지만, 대신 차단이 아닌 폴링이 일어난다는 단점이 있다.
* 조건 변수와 플래그를 조합할 수 있으나, 그런 통신 매커니즘은 필요 이상으로 복잡하다.
* std::promise와 future객체를 사용하면 이러한 문제점들을 피할 수 있지만, 그런 접근 방식은 공유 상태에 힙 메모리를 사용하며, 단발성 통신만 가능하다.
