# 항목 29: 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라

## 개요

- C++11 의 주인공인 이동 의미론(move semantics)을 어설프게 알고 있으면 이동연산이 표준 컨테이너에 대해 만능이라고 생각하기 쉽다.
- 하지만 이동 의미론은 모든 이동을 빠르게 만들어주는 만능의 개념이 아니다.
- 이번 항목의 목적은 이동 의미론에 대해 **"근거 있는"** 기대를 가지게 하는 것이다.

---

## 이동 연산이 없는 경우

- C++11 에서는 이동 연산을 명시적으로 지원하지 않는 형식에 대해 자동으로 이동 연산들을 작성해준다. 하지만 이 자동 작성은 다음과 같은 제한이 있다.
  + 복사 연산, 이동 연산, 소멸자 중 하나라도 있을 경우 (항목 17 참고)
  + 이동 연산을 비활성화 시켜놓은 경우 (항목 11 참고)

---

## 이동이 더 빠르지 않은 경우

- C++11 표준 라이브러리의 모든 컨테이너는 이동을 지원하지만, 모든 컨테이너의 이동이 복사보다 저렴한 것은 아니다.
- 특정 컨테이너들은 컨테이너 내부의 요소들이 이동 연산의 조건을 만족할 수 없는 경우도 있기 때문이다.

### `std::array`

- `std::array` 컨테이너는 기본 배열에 STL 인터페이스를 씌운 것이다.
- `std::array` 컨테이너는 자신의 내용을 힙에 저장하는 다른 표준 컨테이너와는 근본적으로 다르다.
- `std::array` 컨테이너는 내용을 `std::array` 객체 자체에 직접 저장한다.

```C++
std::vector<Widget> vw1;
/* do something with vw1 */
auto vw2 = std::move(vw1);
```

- `std::vector`는 내용을 힙 메모리에 저장하고 클래스 내부에는 이에 대한 포인터를 저장하기 때문에 이동 연산에 있어서 O(1)의 수행시간을 가진다.

```C++
std::array<Widget, 1000> ar1;
/* do something with ar1 */
auto ar2 = std::move(ar1);
```

- `std::array`는 객체에 내부에 내용을 직접 저장하기 때문에 이동 연산에 있어서 O(n)의 수행시간을 가진다.

### `std::string`

- `std::string`은 일반적으로 O(1)시간 이동과 O(n)시간 복사를 제공한다.
- 하지만 SSO(small string optimization)의 경우에는 이동 연산이 복사 연산과 마찬가지로 O(n)의 수행시간을 가지게 된다.
  + SSO는 저장하는 문자열의 길이가 짧은 경우에 문자열을 힙에 저장하지 않고 객체 내부에 저장함으로써 최적화를 한다.

---

## 이동을 사용할 수 없는 경우

- 표준 라이브러리의 일부 컨테이너 연산들은 **강한 예외 안전성**을 보장한다.
- 이 "보장"이란 구식 C++98 코드를 C++11에서 컴파일 해도 코드가 망가지지 않게 하기 위해, 이동 연산들이 예외를 던지지 않을 때에만 복사 연산들을 이동 연산들로 대체한다는 것이다. (항목 14 참조)
- 따라서 코드의 특정 지점에서 이동 연산이 적합하다고 해도, 해당 이동 연산이 `noexcept`로 선언되어 있지 않으면 컴파일러는 복사 연산을 호출할 수 있다.

---

## 결론

- 템플릿과 같이 변수들의 형식을 알 수 없는 경우에는 이동 연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라.
- 구체적인 형식을 미리 알 수 있고, 이동 연산들이 실행될 문맥에서 그 형식을 사용하는 경우에는 복사 연산들이 더 저렴한 이동 연산들로 대체될 것이라고 믿어도 좋다.